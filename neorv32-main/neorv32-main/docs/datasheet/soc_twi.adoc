<<<
:sectnums:
==== Two-Wire Serial Interface Controller (TWI)

[cols="<3,<3,<4"]
[frame="topbot",grid="none"]
|=======================
| Hardware source file(s): | neorv32_twi.vhd | 
| Software driver file(s): | neorv32_twi.c |
|                          | neorv32_twi.h |
| Top entity port:         | `twi_sda_io` | 1-bit bi-directional serial data
|                          | `twi_scl_io` | 1-bit bi-directional serial clock
| Configuration generics:  | _IO_TWI_EN_ | implement TWI controller when _true_
| CPU interrupts:          | fast IRQ channel 7 | transmission done interrupt (see <<_processor_interrupts>>)
|=======================


**Theory of Operation**

The two wire interface - also called "IÂ²C" - is a quite famous interface for connecting several on-board
components. Since this interface only needs two signals (the serial data line `twi_sda_io` and the serial
clock line `twi_scl_io`) - despite of the number of connected devices - it allows easy interconnections of
several peripheral nodes.

The NEORV32 TWI implements a **TWI controller**. It supports "clock so a slow peripheral can halt
the transmission by pulling the SCL line low. Currently, **no multi-controller
support** is available. Also, the NEORV32 TWI unit cannot operate in peripheral mode.

[IMPORTANT]
The serial clock (SCL) and the serial data (SDA) lines can only be actively driven low by the
controller. Hence, external pull-up resistors are required for these lines.


**TWI Clock Speed**

The TWI clock frequency is defined via the 3-bit _TWI_CTRL_PRSCx_ clock prescaler. The following prescalers
are available:

.TWI prescaler configuration
[cols="<4,^1,^1,^1,^1,^1,^1,^1,^1"]
[options="header",grid="rows"]
|=======================
| **`TWI_CTRL_PRSCx`**        | `0b000` | `0b001` | `0b010` | `0b011` | `0b100` | `0b101` | `0b110` | `0b111`
| Resulting `clock_prescaler` |       2 |       4 |       8 |      64 |     128 |    1024 |    2048 |    4096
|=======================

Based on the _TWI_CTRL_PRSCx_ configuration, the actual TWI clock frequency f~SCL~ is derived from the processor
main clock f~main~ and is determined by:

_**f~SCL~**_ = _f~main~[Hz]_ / (4 * `clock_prescaler`)


**TWI Transfers**

The TWI is enabled via the _TWI_CTRL_EN_ bit in the `CTRL` control register. The user program can start / stop a
transmission by issuing a START or STOP condition. These conditions are generated by setting the
according bits (_TWI_CTRL_START_ or _TWI_CTRL_STOP_) in the control register.

Data is transferred via the TWI bus by writing a byte to the `DATA` register. The written byte is send via the TWI bus
and the received byte from the bus is also available in this register after the transmission is completed. The TWI
operation (transmitting data or performing a START or STOP condition) is in progress as long as the _TWI_CTRL_BUSY_ bit
in the control register is set.


**TWI ACK/NACK and MACK**

An accessed TWI peripheral can acknowledge each transferred byte. When the _TWI_CTRL_ACK_ bit is set after a
completed transmission the accessed peripheral has send an acknowledge. If it is cleared after a
transmission, the peripheral has send a not-acknowledge (NACK).

The NEORV32 TWI controller can also send an ACK by itself ("controller acknowledge _MACK_") right after transmitting a
byte by pulling SDA low during the ACK time slot. Many TWI devices require this MACK to acknowledge a data read operation.
Set the control register's _TWI_CTRL_MACK_ bit to activate this feature. If this bit is cleared, the ACK/NACK generated by
the peripheral is sampled in this time slot instead (normal mode).


**TWI Bus Status**

The TWI controller can check if the TWI bus is currently claimed (SCL and SDA both low). The bus can be claimed by the
NEORV32 TWI itself or by any other controller. Bit _TWI_CTRL_CLAIMED_ of the control register will be set if the bus
is currently claimed.


**Summary**

In summary, the following _independent_ TWI operations can be triggered by the application program to conduct
a TWI transfer:

[start=1]
. generate START condition by setting _TWI_CTRL_START_
. transfer one byte while also sampling one byte from the bus (this also samples ACK/NACK or generates a
controller ACK "MACK" if _TWI_CTRL_MACK_ is set) by writing data to `NEORV32_TWI.DATA`; this step can be repeated to
send/receive an arbitrary number of bytes
. optionally generate another START condition (as REPEATED-START condition) by setting _TWI_CTRL_START_
. generate STOP condition by setting _TWI_CTRL_STOP_

[TIP]
A transmission can be terminated at any time by disabling the TWI module
by clearing the _TWI_CTRL_EN_ control register bit. This will also reset the whole module.

[NOTE]
When reading data from a device, all-one (`0xFF`) has to be written to TWI data register `NEORV32_TWI.DATA`
so the accessed device can actively pull-down SDA when required.


**TWI Interrupt**

The TWI module provides a single interrupt to signal "transmission done" to the CPU. Whenever the TWI
module completes the current transmission of one byte the interrupt is triggered. Note the the interrupt
is **not** triggered when completing a START or STOP condition. Once triggered, the interrupt has to be
explicitly cleared again by writing zero to the according <<_mip>> CSR bit.


**Register Map**

.TWI register map (`struct NEORV32_TWI`)
[cols="<2,<2,<4,^1,<7"]
[options="header",grid="all"]
|=======================
| Address | Name [C] | Bit(s), Name [C] | R/W | Function
.10+<| `0xffffffb0` .10+<| `NEORV32_TWI.CTRL` <|`0` _TWI_CTRL_EN_       ^| r/w <| TWI enable, reset if cleared
                                              <|`1` _TWI_CTRL_START_    ^| -/w <| generate START condition, auto-clears
                                              <|`2` _TWI_CTRL_STOP_     ^| -/w <| generate STOP condition, auto-clears
                                              <|`3` _TWI_CTRL_PRSC0_    ^| r/w .3+<| 3-bit clock prescaler select
                                              <|`4` _TWI_CTRL_PRSC1_    ^| r/w
                                              <|`5` _TWI_CTRL_PRSC2_    ^| r/w
                                              <|`6` _TWI_CTRL_MACK_     ^| r/w <| generate controller-ACK for each transmission ("MACK")
                                              <|`29` _TWI_CTRL_CLAIMED_ ^| r/- <| set if the TWI bus is claimed by any controller
                                              <|`30` _TWI_CTRL_ACK_     ^| r/- <| ACK received when set, NACK received when cleared
                                              <|`31` _TWI_CTRL_BUSY_    ^| r/- <| transfer/START/STOP in progress when set
| `0xffffffb4` | `NEORV32_TWI.DATA` |`7:0` _TWI_DATA_MSB_ : _TWI_DATA_LSB_ | r/w | receive/transmit data
|=======================
